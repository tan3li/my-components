{"version":3,"file":"nestedatatablekeyboardcoordinategetter.js","sourceRoot":"","sources":["../../../../src/components/datadisplay/datatable/nestedatatablekeyboardcoordinategetter.ts"],"names":[],"mappings":"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","sourcesContent":["import {closestCorners, DroppableContainer, getFirstCollision, KeyboardCoordinateGetter} from '@dnd-kit/core';\nimport {KeyboardEventKey} from '../../../constants/index.js';\n\nconst eventKeys: string[] = [KeyboardEventKey.ArrowDown, KeyboardEventKey.ArrowUp];\n\nconst enum Direction {\n    Up = -1,\n    Down = 1\n}\n\nconst X_OFFSET = 30;\n\nexport const nestedDataTableKeyboardCoordinateGetter: KeyboardCoordinateGetter = (event, args) => {\n    event.preventDefault();\n\n    const eventKey = event.key;\n    const {active, collisionRect, droppableContainers, droppableRects} = args.context;\n\n    if (!eventKeys.includes(eventKey) || !active || !collisionRect) {\n        return;\n    }\n\n    const filteredContainers: DroppableContainer[] = [];\n    const activeId = active.id;\n    const heightPercentage = 0.25;\n    let direction: Direction | undefined;\n\n    droppableContainers.getEnabled().forEach((entry) => {\n        if (!entry || entry?.disabled) {\n            return;\n        }\n\n        const entryId = entry.id;\n        const rect = droppableRects.get(entryId);\n\n        if (!rect) {\n            return;\n        }\n\n        switch (eventKey) {\n            case KeyboardEventKey.ArrowDown:\n                if (entryId !== activeId && collisionRect.top < rect.top + rect.height * heightPercentage) {\n                    filteredContainers.push(entry);\n                }\n                direction = Direction.Down;\n                break;\n            case KeyboardEventKey.ArrowUp:\n                if (entryId !== activeId && collisionRect.top > rect.top - rect.height * heightPercentage) {\n                    filteredContainers.push(entry);\n                }\n                direction = Direction.Up;\n                break;\n            default:\n                break;\n        }\n    });\n\n    const collisions = closestCorners({\n        active,\n        collisionRect,\n        droppableRects,\n        droppableContainers: filteredContainers,\n        pointerCoordinates: null\n    });\n    const closestId = getFirstCollision(collisions, 'id');\n\n    if (closestId !== null) {\n        const newDroppable = droppableContainers.get(closestId);\n        const newRect = newDroppable?.rect.current;\n\n        if (newRect && direction) {\n            const activeTop = collisionRect.top;\n            const {top: newRectTop, height: newRectHeight} = newRect;\n            const afterThreshold = newRectTop + newRectHeight * heightPercentage;\n            const beforeThreshold = newRectTop - newRectHeight * heightPercentage;\n            let y: number | undefined;\n\n            if (direction === Direction.Up) {\n                if (activeTop > afterThreshold + 1) {\n                    y = afterThreshold + 1;\n                } else if (activeTop > newRectTop) {\n                    y = newRectTop;\n                } else {\n                    y = beforeThreshold - 1;\n                }\n            } else if (direction === Direction.Down) {\n                if (activeTop < beforeThreshold - 1) {\n                    y = beforeThreshold - 1;\n                } else if (activeTop < newRectTop) {\n                    y = newRectTop;\n                } else {\n                    y = afterThreshold + 1;\n                }\n            }\n\n            if (y !== undefined) {\n                return {\n                    x: newRect.left + X_OFFSET,\n                    y\n                };\n            }\n        }\n    }\n};\n"]}