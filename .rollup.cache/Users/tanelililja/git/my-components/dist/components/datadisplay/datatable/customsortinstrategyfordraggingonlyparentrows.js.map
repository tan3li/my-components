{"version":3,"file":"customsortinstrategyfordraggingonlyparentrows.js","sourceRoot":"","sources":["../../../../src/components/datadisplay/datatable/customsortinstrategyfordraggingonlyparentrows.ts"],"names":[],"mappings":"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","sourcesContent":["import type {ClientRect} from '@dnd-kit/core';\n\ninterface SortingParams {\n    activeNodeRect: ClientRect | null;\n    activeIndex: number;\n    index: number;\n    rects: ClientRect[];\n    overIndex: number;\n}\n\nconst defaultScale = {\n    scaleX: 1,\n    scaleY: 1\n};\n\nfunction calculateItemGap(rects: ClientRect[], index: number, activeIndex: number) {\n    const currentRect = rects[index];\n\n    if (!currentRect) {\n        return 0;\n    }\n\n    if (activeIndex < index) {\n        const prevRect = rects[index - 1];\n\n        return prevRect ? currentRect.top - (prevRect.top + prevRect.height) : 0;\n    }\n\n    const nextRect = rects[index + 1];\n\n    return nextRect ? nextRect.top - (currentRect.top + currentRect.height) : 0;\n}\n\nfunction getParentBoundaryIndex<TModel extends {level: number}>(\n    rows: TModel[],\n    startIndex: number,\n    searchForward: boolean\n): number {\n    let boundaryIdx = startIndex;\n\n    while (rows[boundaryIdx]?.level !== 0) {\n        boundaryIdx += searchForward ? 1 : -1;\n    }\n\n    return boundaryIdx;\n}\n\nfunction isOverIdxInsideGroup<TModel extends {level: number}>(\n    {activeIndex, index, overIndex}: SortingParams,\n    rows: TModel[]\n): boolean {\n    const currentRowLevel = rows[index].level;\n    const isParentRow = currentRowLevel === 0 && rows[index + 1]?.level === 1;\n    const isChildRow = currentRowLevel === 1;\n    let isInsideGroup = false;\n\n    if (isChildRow || (activeIndex < index && isParentRow)) {\n        const lastChildIdx = getParentBoundaryIndex(rows, isChildRow ? index : index + 1, true);\n        const overItemParentIdx = getParentBoundaryIndex(rows, isParentRow ? index : index - 1, false);\n\n        isInsideGroup =\n            (overIndex > activeIndex && overItemParentIdx <= overIndex && overIndex <= lastChildIdx - 1) ||\n            (overIndex < activeIndex && overItemParentIdx + 1 <= overIndex && overIndex <= lastChildIdx);\n    }\n\n    return isInsideGroup;\n}\n\nfunction isValidDropzoneIndex<TModel extends {level: number}>(sortingParams: SortingParams, rows: TModel[]): boolean {\n    const {activeIndex, index, overIndex} = sortingParams;\n    const goingUp = activeIndex > overIndex;\n    const goingDown = activeIndex < overIndex;\n    const overItem = rows[overIndex];\n    const overItemLevel = overItem.level;\n    const isAboveParent = overItemLevel === 0 && index <= overIndex;\n    const nextRow = rows[overIndex + 1];\n    const prevRow = rows[overIndex - 1];\n    const nextOrPrevRowIsChild =\n        (nextRow && nextRow.level !== 0 && goingDown) || (prevRow && prevRow.level !== 0 && goingUp);\n    const isBetweenParentAndChildren = overItemLevel === 0 && index === overIndex && nextOrPrevRowIsChild;\n    const isBelowLastChildInGroup = overItemLevel === 1 && (!nextRow || nextRow.level === 0);\n    const isBetweenStandaloneParents = overItemLevel === 0 && index !== activeIndex;\n    const isBetweenChildren = overItemLevel === 1 && nextOrPrevRowIsChild;\n\n    // Define valid drop zones\n    return (\n        !isOverIdxInsideGroup(sortingParams, rows) ||\n        ((isAboveParent || isBelowLastChildInGroup || isBetweenStandaloneParents) &&\n            !isBetweenChildren &&\n            !isBetweenParentAndChildren)\n    );\n}\n\nexport function customSortingStrategyForDraggingOnlyParentRows<TData extends {level: number}>(\n    sortingParams: SortingParams,\n    rows: TData[]\n): {\n    scaleX: number;\n    scaleY: number;\n    x: number;\n    y: number;\n} | null {\n    const {activeIndex, activeNodeRect: fallbackActiveRect, index, overIndex, rects} = sortingParams;\n\n    const activeNodeRect = rects[activeIndex] ?? fallbackActiveRect;\n\n    if (!activeNodeRect) {\n        return null;\n    }\n\n    const activeItem = rows[activeIndex];\n\n    // Ensure only level 0 (parent) items are draggable\n    if (activeItem.level !== 0) {\n        return {x: 0, y: 0, ...defaultScale};\n    }\n\n    const isValidDropZone = isValidDropzoneIndex(sortingParams, rows);\n\n    if (index === activeIndex) {\n        const overRect = rects[overIndex];\n\n        if (!overRect) {\n            return null;\n        }\n\n        const yTransform =\n            index < overIndex ?\n                overRect.top + overRect.height - (activeNodeRect.top + activeNodeRect.height)\n            :   overRect.top - activeNodeRect.top;\n\n        return {x: 0, y: yTransform, ...defaultScale};\n    }\n\n    const itemGap = calculateItemGap(rects, index, activeIndex);\n\n    if (index > activeIndex && index <= overIndex && isValidDropZone) {\n        return {\n            x: 0,\n            y: -activeNodeRect.height - itemGap,\n            ...defaultScale\n        };\n    }\n\n    if (index < activeIndex && index >= overIndex && isValidDropZone) {\n        return {\n            x: 0,\n            y: activeNodeRect.height + itemGap,\n            ...defaultScale\n        };\n    }\n\n    return {x: 0, y: 0, ...defaultScale};\n}\n"]}